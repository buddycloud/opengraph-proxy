{
  "name": "apicache",
  "version": "0.0.12",
  "description": "An ultra-simplified API/JSON response caching middleware for Express/Node using plain-english durations.",
  "main": "./lib/apicache.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/kwhitley/apicache.git"
  },
  "keywords": [
    "cache",
    "API",
    "response",
    "express",
    "JSON",
    "duration",
    "middleware",
    "simple",
    "memory"
  ],
  "author": {
    "name": "K. R. Whitley",
    "email": "contact@krwhitley.com",
    "url": "http://krwhitley.com/"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://en.wikipedia.org/wiki/MIT_License"
    }
  ],
  "bugs": {
    "url": "https://github.com/kwhitley/apicache/issues"
  },
  "devDependencies": {
    "grunt": "latest",
    "nodeunit": "latest",
    "grunt-contrib-jshint": "latest",
    "grunt-contrib-nodeunit": "latest",
    "grunt-contrib-watch": "latest"
  },
  "scripts": {
    "test": "grunt"
  },
  "dependencies": {
    "memory-cache": "0.0.5",
    "lodash": "~1.3.1",
    "inflection": "~1.2.6"
  },
  "readme": "apicache\n========\n\nAn ultra-simplified API/JSON response caching middleware for Express/Node using plain-english durations.\n\n## Why?\n\nBecause caching of simple data/responses should ALSO be simple.\n\nThis day and age, with less and less heavy lifting done on the server,\nthe most common thing we find ourselves doing is\nletting the server power the API.  Whether the data is stored in Mongo, SQL,\nCouchDB, or whatever - you get a request, you fetch the data, and you return\nthe data.  Sometimes these fetches are costly and you want to cache the response\nso the next hit doesn't hammer your server.  This is why caching exists.\n\nThe problem is, with so many cache options, people are still left to fend for themselves\nwhen it comes to implementation.  It often boils down to a manual process similar to the following:\n\n1. Get the request\n2. Check your cache for the key/url.\n3. If found, intercept and output the cached version.\n4. If not, do the work, cache it, and output.\n\nYou're still left wrapping the content of each request with this cache-checking mechanism.\n\nNow it can be as simple as telling the request that you want to use a cache, and for\nhow long results should be cached (*in plain English*, not milliseconds, because\nwho really wants to calculate that each time?).\n\n## Installation\n\n```\nnpm install apicache\n```\n\n## API\n\n- `apicache.clear([target])` - clears cache target (key or group), or entire cache if no value passed, returns new index.\n- `apicache.getIndex()` - returns current cache index [of keys]\n- `apicache.middleware([duration])` - the actual middleware that will be used in your routes.  `duration` is in the following format \"[length] [unit]\", as in `\"10 minutes\"` or `\"1 day\"`.\n- `apicache.options([options])` - getter/setter for options.  If used as a setter, this function is chainable, allowing you to do things such as... say... return the middleware.\n\n#### Available Options (first value is default)\n\n```js\n{\n  debug:            false|true,   // if true, enables console output\n  defaultDuration:  3600000,      // should be a number (in ms), defaults to 1 hour\n  enabled:          true|false,   // if false, turns off caching globally (useful on dev)\n}\n```\n\n## Usage\n\nTo use, simply inject the middleware (example: `apicache('5 minutes')`) into your routes.  Everything else is automagic.\n\n```js\nvar apicache = require('apicache').options({ debug: true }).middleware;\n\n...\n\n// an example route\napp.get('/api/v1/myroute', apicache('5 minutes'), function(req, res, next) {\n  // do some work... this will only occur once per 5 minutes\n  res.send({ foo: bar });\n});\n\n```\n\n## Cache Key Groups\n\nOftentimes it benefits us to group cache entries, for example, by collection (in an API).  This\nwould enable us to clear all cached \"post\" requests if we updated something in the \"post\" collection\nfor instance. Adding a simple `req.apicacheGroup = [somevalue];` to your route enables this.  See example below:\n\n```js\n\nvar apicache  = require('apicache');\nvar cache     = Apicache.middleware;\n\n// GET collection/id\napp.get('/api/:collection/:id?', cache('1 hour'), function(req, res, next) {\n  req.apicacheGroup = req.params.collection;\n  // do some work\n  res.send({ foo: 'bar' });\n});\n\n// POST collection/id\napp.post('/api/:collection/:id?', function(req, res, next) {\n  // update model\n  apicache.clear(req.params.collection);\n  res.send(200);\n});\n\n```\n\nAdditionally, you could add manual cache control to the previous project with routes such as these:\n\n```js\n\n// GET apicache index (for the curious)\napp.get('/api/cache/index', function(req, res, next) {\n  res.send(apicache.getIndex());\n});\n\n// GET apicache index (for the curious)\napp.get('/api/cache/clear/:key?', function(req, res, next) {\n  res.send(200, ApiCache.clear(req.params.key || req.query.key));\n});\n\n```\n\n## Client-Side Bypass\n\nWhen sharing `GET` routes between admin and public sites, you'll likely want the\nroutes to be cached from your public client, but NOT cached when from the admin client. This\nis achieved by sending a `\"x-apicache-bypass\": true` header along with the requst from the admin.\nThe presence of this header flag will bypass the cache, ensuring you aren't looking at stale data.\n\n## Limitations\n\n- `apicache` is currently an in-memory cache, built upon [memory-cache](https://github.com/ptarjan/node-cache).  It may later be expanded to allow other cache-layers.\n- This should only be used for JSON responses (as from an API) - if for no other reason, because it will return the cached response as `application/json`.  There's a reason it's called `apicache`.\n\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/kwhitley/apicache",
  "_id": "apicache@0.0.12",
  "_shasum": "37ba7e9b942de54bd97903483be259b8d71bc8cf",
  "_from": "apicache@",
  "_resolved": "https://registry.npmjs.org/apicache/-/apicache-0.0.12.tgz"
}
